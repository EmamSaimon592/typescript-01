тЬЕ generic function with Array

function getFirstElement<T>(arr: T[]): T {
  return arr[0];
}

const firstNum = getFirstElement<number>([10, 20, 30]); // 10
const firstStr = getFirstElement(['a', 'b', 'c']); // "a"

console.log(firstNum);
console.log(firstStr);

....................................

тЬЕ Aysnc function in ts
async function getData(): Promise<string> {
  throw new Error("Something went wrong!");
}

ЁЯФ╕ getData() рж╣рж▓ ржПржХржЯрж╛ async functionред
ЁЯФ╕ ржХрж┐ржирзНрждрзБ ржПржЯрж╛ ржХрзЛржи data return ржирж╛ ржХрж░рзЗ, ржмрж░ржВ error ржЫрзБржБрзЬрзЗ ржжрзЗрзЯ (throw)ред

async function run() {
  try {
    const data = await getData();  // ржПржЦрж╛ржирзЗ error рж╣ржмрзЗ
    console.log(data);
  } catch (error) {
    console.error("Error:", (error as Error).message); // error message ржжрзЗржЦрж╛ржмрзЗ
  }
}

ЁЯФ╕ run() ржлрж╛ржВрж╢ржи getData()-ржХрзЗ ржХрж▓ ржХрж░рзЗ await ржжрж┐рзЯрзЗред
ЁЯФ╕ ржпрзЗрж╣рзЗрждрзБ getData() error ржжрзЗрзЯ, рждрж╛ржЗ try block ржП ржирж╛ ржЧрж┐рзЯрзЗ catch block-ржП ржЪрж▓рзЗ ржпрж╛рзЯред
ЁЯФ╕ catch block ржП рж╕рзЗржЗ error message ржжрзЗржЦрж╛ржирзЛ рж╣рзЯред

 ржпржжрж┐ Error ржирж╛ ржжрж┐рждрж╛ржо?
async function getData(): Promise<string> {
  return "Hello world!";
}
рждрж╛рж╣рж▓рзЗ output рж╣ржд:
Hello world!
------------------------------------------------------------


тЬЕ Enum
1. Auto-incremented Values (рж╕ржВржЦрзНржпрж╛ рж╕рзНржмрзЯржВржХрзНрж░рж┐рзЯржнрж╛ржмрзЗ ржмрж╛рзЬрзЗ)
enum Color {
  Red,    // 0
  Green,  // 1
  Blue    // 2
}

2.Custom Numeric Values (ржирж┐ржЬрзЗрж░ ржорждрзЛ ржХрж░рзЗ рж╕ржВржЦрзНржпрж╛ ржжрзЗржУрзЯрж╛):
enum Color {
  Red = 1,
  Green = 5,
  Blue = 10
}

3. String Enums (рж╕рзНржЯрзНрж░рж┐ржВ ржнрзНржпрж╛рж▓рзБ рж╕рж╣ enum):
enum Direction {
  North = "NORTH",
  South = "SOUTH",
  East = "EAST",
  West = "WEST"
}

4. Heterogeneous Enum (number + string ржПржХрж╕рж╛ржерзЗ)
enum Example {
  No = 0,
  Yes = "YES"
}

ржХрзЗржи enum ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи?
тЬЕ ржХрзЛржб ржХрзНрж▓рж┐ржи ржУ ржмрзЛржЭрж╛рж░ рж╕рж╣ржЬ
тЬЕ ржорзНржпрж╛ржЬрж┐ржХ ржирж╛ржорзНржмрж╛рж░ ржПрзЬрж┐рзЯрзЗ ржпрж╛рзЯ
тЬЕ ржЯрж╛ржЗржк рж╕рзЗржл тАУ ржнрзБрж▓ ржнрзНржпрж╛рж▓рзБ ржзрж░рждрзЗ ржкрж╛рж░рзЗ ржХржорзНржкрж╛ржЗрж▓ ржЯрж╛ржЗржорзЗржЗ

тЬФрж╢рзЗрж╖ ржХржерж╛:
TypeScript ржП enum ржПржХржЯрж┐ powerful feature, ржпрж╛ ржЖржкржирж╛рж░ constant values ржЧрзБрж▓рзЛржХрзЗ рж╕рзБржирзНржжрж░ржнрж╛ржмрзЗ handle ржХрж░рждрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рзЗред ржПржЯрж╛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж▓рзЗ ржХрзЛржб ржмрзЗрж╢рж┐ readable ржУ maintainable рж╣рзЯред

---------------------------

In TypeScript, OOPs (Object-Oriented Programming System) is fully supported using features like:

1.Classes and Objects 

2. Inheritance (ржЙрждрзНрждрж░рж╛ржзрж┐ржХрж╛рж░) ---> use keyword( тЬЕextends)

3. Encapsulation (ржЧрзЛржкржирждрж╛ рж░ржХрзНрж╖рж╛)---> public , private , protected /Encapsulation рж╣рж▓рзЛ OOP-ржПрж░ principle, ржпрж╛ ржжрж┐рзЯрзЗ ржЖржорж░рж╛ class-ржПрж░ internal data ржмрж╛ properties ржХрзЗ hide ржХрж░рж┐редржЕржирзНржп class ржмрж╛ object рж╕рж░рж╛рж╕рж░рж┐ access ржХрж░рждрзЗ ржкрж╛рж░рзЗ ржирж╛редрж╢рзБржзрзБ methods ржПрж░ ржорж╛ржзрзНржпржорзЗ access ржмрж╛ modify ржХрж░рж╛ ржпрж╛ржпрж╝редржПржЗ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ржХрзЗ ржмрж▓рж╛ рж╣ржпрж╝ data hiding ржмрж╛ ржЧрзЛржкржирждрж╛ рж░ржХрзНрж╖рж╛ред

ЁЯФ┤ private = рж╢рзБржзрзБржорж╛рждрзНрж░ class-ржПрж░ ржнрж┐рждрж░ ржерзЗржХрзЗ access ржХрж░рж╛ ржпрж╛ржмрзЗ.
ЁЯФ┤ protected = class ржПржмржВ subclass ржерзЗржХрзЗ access ржХрж░рж╛ ржпрж╛ржмрзЗ
ЁЯФ┤ public =  class, subclass, object рж╕ржмржЦрж╛ржи ржерзЗржХрзЗ access ржХрж░рж╛ ржпрж╛ржмрзЗ (default)

4. Polymorphism (ржмрж╣рзБрж░рзБржкрждрж╛)

5.Abstraction

6. Interfaces : 
Interface рж╣ржЪрзНржЫрзЗ TypeScript-ржПрж░ ржПржоржи ржПржХржЯрж┐ feature, ржпрж╛ ржжрж┐рзЯрзЗ ржЖржорж░рж╛ ржПржХржЯрж┐ object ржмрж╛ class-ржПрж░ structure ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рждрзЗ ржкрж╛рж░рж┐ред

ржПржЯрж╛ ржПржХржзрж░ржирзЗрж░ contract ржмрж╛ blueprint тАФ ржпрзЗржЦрж╛ржирзЗ ржмрж▓рзЗ ржжрзЗржУрзЯрж╛ рж╣рзЯ, ржПржХржЯрж┐ object ржмрж╛ class-ржПрж░ ржоржзрзНржпрзЗ ржХрзЛржи ржХрзЛржи property/ржорзЗржержб ржерж╛ржХрждрзЗ рж╣ржмрзЗ, ржПржмржВ рж╕рзЗржЧрзБрж▓рзЛрж░ type ржХрзА рж╣ржмрзЗред

тЬЕ Interface ржХрж╛ржжрзЗрж░ ржЬржирзНржп ржжрж░ржХрж╛рж░?

ржпржЦржи ржЖржкржирж┐ ржЪрж╛ржи рж╕ржм object ржмрж╛ class ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржирж┐рзЯржо ржорзЗржирзЗ рждрзИрж░рж┐ рж╣рзЛржХред

ржпржЦржи ржЖржкржирж┐ OOP (Object-Oriented Programming) ржП ржХрж╛ржЬ ржХрж░рзЗржиред

ржмрж╛ Type Checking ржП рж╕рж╛рж╣рж╛ржпрзНржп ржкрзЗрждрзЗ ржЪрж╛ржиред


тЬЕInterface vs Type Alias (ржорзЛржЯрж╛ржорзБржЯрж┐ ржПржХржЗ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рзЗ)
interface User {
  name: string;
}

type Admin = {
  name: string;
}
ржкрж╛рж░рзНржержХрзНржп:

interface ржЖржмрж╛рж░ extend ржХрж░рж╛ ржпрж╛рзЯ, multiple interface inherit ржХрж░рж╛ ржпрж╛рзЯред

type рж╕ржмржХрж┐ржЫрзБрждрзЗ flexible, union, intersection, etc. ржХрж░рж╛ ржпрж╛рзЯред

тЬЕ Interface Extend (Multiple inheritance):
interface A {
  a: string;
}

interface B {
  b: number;
}

interface C extends A, B {
  c: boolean;
}

const obj: C = {
  a: "Hello",
  b: 10,
  c: true
};


тЬЕ Generics ржХрзА?

Generics ржПржоржи ржПржХржЯрж┐ ржлрж┐ржЪрж╛рж░ ржпрж╛ TypeScript-ржП reusable (ржкрзБржиржГржмрзНржпржмрж╣рж╛рж░ржпрзЛржЧрзНржп) code рж▓рж┐ржЦрждрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рзЗред
Generics ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржЖржорж░рж╛ ржПржоржи ржлрж╛ржВрж╢ржи, ржХрзНрж▓рж╛рж╕ ржмрж╛ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ ржмрж╛ржирж╛рждрзЗ ржкрж╛рж░рж┐ ржпрж╛ type-independent, ржЕрж░рзНржерж╛рзО ржПржХрж╛ржзрж┐ржХ ржЯрж╛ржЗржкрзЗ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рзЗред

ЁЯУМ ржЙржжрж╛рж╣рж░ржг рзи: With Generics
function identity<T>(arg: T): T {
  return arg;
}
ржПржЦрж╛ржирзЗ <T> ржорж╛ржирзЗ рж╣рж▓ ржПржХржЯрж╛ Generic Type Parameterред ржПржЯрж╛ future ржП ржпрзЗ ржЯрж╛ржЗржк ржЖрж╕ржмрзЗ, рж╕рзЗржЯрж╛ handle ржХрж░рждрзЗ ржкрж╛рж░рзЗред
identity<number>(5);       // Output: 5
identity<string>("Hello"); // Output: Hello
тЬЕ ржПржЦржи ржПржЗ ржлрж╛ржВрж╢ржиржЯрж╛ number, string, boolean, ржПржоржиржХрж┐ custom ржЯрж╛ржЗржкрзЗржУ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗред
ЁЯУж ржХрзЗржи Generics ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржм?

Code Reusability тАУ ржПржХржЯрж╛ржЗ ржлрж╛ржВрж╢ржи, ржмрж┐ржнрж┐ржирзНржи ржЯрж╛ржЗржкрзЗрж░ ржЬржирзНржп ржХрж╛ржЬ ржХрж░ржмрзЗред

Type Safety тАУ ржЯрж╛ржЗржк ржПрж░рж░ ржХржорзЗ ржпрж╛ржмрзЗ, ржХрж╛рж░ржг ржЯрж╛ржЗржк ржЪрзЗржХ ржХрж░рж╛ рж╣ржмрзЗ compile time ржПред

Better IntelliSense тАУ ржнрзЗрждрж░рзЗрж░ ржЯрж╛ржЗржк ржмрзБржЭрзЗ autocomplete ржжрзЗрзЯред
